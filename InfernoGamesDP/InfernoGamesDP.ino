/*
 Name:		InfernoGamesDP.ino
 Created:	4/14/2019 9:12:33 PM
 Author:	Micke
*/

#include <Wire.h>
//#include <MicroLCD.h>
#include <Adafruit_NeoPixel.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include <Fonts/FreeMonoBold18pt7b.h>
#define RED 0
#define YELLOW 1
#define BLUE 2
#define GREEN 3

#define LED_COLOR_RED pixels.Color(255, 0, 0)
#define LED_COLOR_BLUE pixels.Color(0, 0, 255)
#define LED_COLOR_GREEN pixels.Color(0, 255, 0)
#define LED_COLOR_YELLOW pixels.Color(255, 150, 0)
#define LED_COLOR_WHITE pixels.Color(255, 255, 255)
// Which pin on the Arduino is connected to the NeoPixels?
#define NEO_PIN 13 
// How many NeoPixels are attached to the Arduino?
#define NUMPIXELS 8 
Adafruit_NeoPixel pixels(NUMPIXELS, NEO_PIN, NEO_GRB + NEO_KHZ800);

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 lcd(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

byte buttons[] = { A0, A1, A2, A3 };
#define DEBOUNCE 10 
#define NUMBUTTONS sizeof(buttons)

byte pressed[NUMBUTTONS], justpressed[NUMBUTTONS], justreleased[NUMBUTTONS];
byte previous_keystate[NUMBUTTONS], current_keystate[NUMBUTTONS];

// 'InfernoLogo', 64x64px
const uint8_t infernoLogo[] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xfc, 0x9f, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xf9, 0x8f, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xf3, 0xcf, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xf3, 0xe7, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xe7, 0xf7, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0x8f, 0xf9, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xfe, 0x3f, 0xfe, 0x7f, 0xff, 0xf9,
	0xdf, 0xff, 0xfc, 0x7f, 0xfe, 0x3f, 0xff, 0xf9, 0xdf, 0xff, 0xf8, 0xff, 0xff, 0x3f, 0xff, 0xf9,
	0xdf, 0xff, 0xf9, 0xff, 0xff, 0x1f, 0xff, 0xf9, 0xdf, 0xff, 0xf1, 0xff, 0xff, 0x8f, 0xff, 0xf9,
	0xdf, 0xff, 0xf3, 0xff, 0xff, 0xcf, 0xff, 0xf9, 0xdf, 0xff, 0xe7, 0xff, 0xff, 0xe7, 0xff, 0xf9,
	0xdf, 0xff, 0xef, 0xff, 0xff, 0xf3, 0xff, 0xf9, 0xdf, 0xff, 0xcf, 0xff, 0xff, 0xf9, 0xff, 0xf9,
	0xdf, 0xff, 0x9f, 0xff, 0xff, 0xf9, 0xff, 0xf9, 0xdf, 0xff, 0x3f, 0xff, 0xff, 0xfc, 0xff, 0xf9,
	0xdf, 0xff, 0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xf9, 0xdf, 0xfe, 0x7f, 0xff, 0xff, 0xfe, 0x3f, 0xf9,
	0xdf, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0xf9, 0xdf, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf9,
	0xdf, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xf9, 0xdf, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xef, 0xf9,
	0xdf, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xf9, 0xdf, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf9,
	0xdf, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xf9, 0xdf, 0xef, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf9,
	0xdf, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xf9, 0xde, 0x1f, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xf9,
	0xdc, 0x0f, 0xfe, 0xcf, 0xff, 0xff, 0xff, 0xf9, 0xdf, 0xb0, 0x18, 0x38, 0x20, 0x20, 0x70, 0x79,
	0xdf, 0xbc, 0x48, 0x30, 0x28, 0x31, 0x30, 0x39, 0xdf, 0xbc, 0xce, 0x70, 0x19, 0xb3, 0x27, 0x39,
	0xdf, 0xbd, 0xce, 0x70, 0x19, 0xf7, 0x27, 0x39, 0xdf, 0xbd, 0xce, 0x73, 0xb9, 0xf7, 0x27, 0x39,
	0xde, 0x30, 0x80, 0x38, 0x20, 0xe2, 0x10, 0x79, 0xdc, 0x00, 0x00, 0x3c, 0x60, 0xe0, 0x10, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

void setupDisplay() {
	lcd.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false);
	lcd.setFont(&FreeMonoBold18pt7b);
	lcd.setTextColor(WHITE);
	lcd.clearDisplay();
	lcd.drawBitmap(32, 0, infernoLogo, 64, 64, 1);
	lcd.display();
}

void setupNeoPixelBar() {
	pixels.begin();
	pixels.fill(pixels.Color(0, 0, 0), 0, 8);
	pixels.clear();
	pixels.show();
}

void setupButtons() {
	for (byte i = 0; i< NUMBUTTONS; i++) {
		pinMode(buttons[i], INPUT);
		digitalWrite(buttons[i], HIGH);
	}
}

void check_switches()
{
	static byte previousstate[NUMBUTTONS];
	static byte currentstate[NUMBUTTONS];
	static long lasttime;
	byte index;
	if (millis() < lasttime) {
		lasttime = millis(); // we wrapped around, lets just try again
	}

	if ((lasttime + DEBOUNCE) > millis()) {
		return; // not enough time has passed to debounce
	}
	// ok we have waited DEBOUNCE milliseconds, lets reset the timer
	lasttime = millis();

	for (index = 0; index < NUMBUTTONS; index++) {
		justpressed[index] = 0;       // when we start, we clear out the "just" indicators
		justreleased[index] = 0;

		currentstate[index] = digitalRead(buttons[index]);   // read the button
		if (currentstate[index] == previousstate[index]) {
			if ((pressed[index] == LOW) && (currentstate[index] == LOW)) {
				// just pressed
				justpressed[index] = 1;
			}
			else if ((pressed[index] == HIGH) && (currentstate[index] == HIGH)) {
				// just released
				justreleased[index] = 1;
			}
			pressed[index] = !currentstate[index];  // remember, digital HIGH means NOT pressed
		}
		//Serial.println(pressed[index], DEC);
		previousstate[index] = currentstate[index];   // keep a running tally of the buttons
	}
}

byte getPressedButton() {
	byte thisSwitch = 255;
	check_switches();  //check the switches &amp; get the current state
	for (byte i = 0; i < NUMBUTTONS; i++) {
		current_keystate[i] = justpressed[i];
		if (current_keystate[i] != previous_keystate[i]) {
			if (current_keystate[i]) thisSwitch = i;
		}
		previous_keystate[i] = current_keystate[i];
	}
	return thisSwitch;
}

void writeTeamLogoToDisplay(String displayText) {
	lcd.clearDisplay();
	lcd.setTextSize(1);
	lcd.setCursor((128 - (displayText.length() * 20)) / 2, 45);
	lcd.println(displayText);
	lcd.display();
}

void actOnPressedButton(String displayText, uint32_t ledColor) {
	pixels.fill(ledColor, 0, 8);
	pixels.show();

	writeTeamLogoToDisplay(displayText);
	
	noTone(8);
	tone(8, 523, 100);
}

void handleButtons(byte pressedButton) {
	switch (pressedButton)
	{
	case RED:
		actOnPressedButton("BEAR", LED_COLOR_RED);
		break;
	case YELLOW:
		actOnPressedButton("N/A", LED_COLOR_YELLOW);
		break;
	case BLUE:
		actOnPressedButton("STF", LED_COLOR_BLUE);
		break;
	case GREEN:
		actOnPressedButton("SOR", LED_COLOR_GREEN);
		break;
	}

}

void setup(){
	setupButtons();
	setupNeoPixelBar();
	setupDisplay();
}

void loop() {
	handleButtons(getPressedButton());
}
